<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MPU-6050 Rocket Visualizer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #111827;
            color: #e5e7eb;
            overflow: hidden;
        }
        #info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background-color: rgba(31, 41, 55, 0.8);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(75, 85, 99, 0.5);
            backdrop-filter: blur(10px);
            max-width: 320px;
            transition: all 0.3s ease;
        }
        .status-dot {
            height: 10px;
            width: 10px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
            transition: background-color 0.5s ease;
        }
        .status-disconnected { background-color: #ef4444; }
        .status-connected { background-color: #22c55e; }
        .readout-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem 1rem; }
    </style>
</head>
<body class="w-screen h-screen m-0 p-0 flex items-center justify-center">

    <div id="container" class="w-full h-full absolute top-0 left-0"></div>

    <div id="info-panel" class="shadow-2xl">
        <h1 class="text-xl font-bold mb-2 text-white">MPU-6050 Rocket Visualizer</h1>
        <div class="flex items-center mb-4">
            <span id="status-dot" class="status-dot status-disconnected"></span>
            <span id="status-text" class="text-sm text-gray-300">Disconnected</span>
        </div>
        <p class="text-sm text-gray-400 mb-4">Connect to the Arduino and use 'Zero' to calibrate the initial position.</p>
        
        <div class="grid grid-cols-2 gap-2">
            <button id="connect-button" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">Connect</button>
            <button id="zero-button" class="w-full bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg transition-colors" disabled>Zero Position</button>
        </div>

        <div class="mt-4 text-xs text-gray-400 readout-grid">
            <p><span class="font-semibold">Yaw:</span> <span id="yaw-val">0.00</span>째</p>
            <p><span class="font-semibold">Pitch:</span> <span id="pitch-val">0.00</span>째</p>
            <p><span class="font-semibold">Roll:</span> <span id="roll-val">0.00</span>째</p>
            <p><span class="font-semibold">Temp:</span> <span id="temp-val">0.00</span> 째F</p>
            <p><span class="font-semibold">Accel:</span> <span id="accel-val">0.00</span> G</p>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        let scene, camera, renderer, modelGroup;
        let port, reader, lineBuffer = '';
        
        // --- Store current raw sensor readings ---
        let currentQuaternion = new THREE.Quaternion();
        let currentAccelG = 0;
        
        // --- Store the offset values when "Zero" is clicked ---
        let zeroOffsetQuaternion = new THREE.Quaternion(); // Identity quaternion
        let zeroOffsetAccel = 0;

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111827);
            scene.fog = new THREE.Fog(0x111827, 10, 50);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;

            const container = document.getElementById('container');
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            container.appendChild(renderer.domElement);

            // Create the Rocket Model
            const rocketModel = new THREE.Group();
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0xc0c0c0, metalness: 0.8, roughness: 0.2 });
            const accentMaterial = new THREE.MeshStandardMaterial({ color: 0xff4136, metalness: 0.5, roughness: 0.5 });
            const bodyGeometry = new THREE.CylinderGeometry(0.3, 0.3, 2.5, 32);
            const rocketBody = new THREE.Mesh(bodyGeometry, bodyMaterial);
            rocketModel.add(rocketBody);
            const noseGeometry = new THREE.ConeGeometry(0.4, 1, 32);
            const noseCone = new THREE.Mesh(noseGeometry, accentMaterial);
            noseCone.position.y = 1.75;
            rocketModel.add(noseCone);
            for (let i = 0; i < 3; i++) {
                const finGeometry = new THREE.BoxGeometry(1.0, 0.7, 0.1);
                const fin = new THREE.Mesh(finGeometry, accentMaterial);
                const angle = (i / 3) * Math.PI * 2;
                fin.position.x = Math.cos(angle) * 0.5;
                fin.position.z = Math.sin(angle) * 0.5;
                fin.position.y = -0.75;
                fin.rotation.y = -angle;
		fin.rotation.z = -10;
                rocketModel.add(fin);
            }
            
            modelGroup = new THREE.Group();
            modelGroup.add(rocketModel);
            scene.add(modelGroup);

            // Lighting and Helpers
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 7.5);
            scene.add(directionalLight);
            const gridHelper = new THREE.GridHelper(20, 20, 0x4b5563, 0x374151);
            scene.add(gridHelper);

            // Event Listeners
            document.getElementById('connect-button').addEventListener('click', connectSerial);
            document.getElementById('zero-button').addEventListener('click', zeroPosition);
            window.addEventListener('resize', onWindowResize, false);
            
            animate();
        }
        
        async function connectSerial() {
            try {
                port = await navigator.serial.requestPort();
                await port.open({ baudRate: 115200 });
                updateConnectionStatus(true);
                readUntilClosed();
            } catch (e) {
                updateConnectionStatus(false);
            }
        }

        async function readUntilClosed() {
            const textDecoder = new TextDecoderStream();
            const readableStreamClosed = port.readable.pipeTo(textDecoder.writable).catch(error => {});
            reader = textDecoder.readable.getReader();
            try {
                while (true) {
                    const { value, done } = await reader.read();
                    if (done) break;
                    lineBuffer += value;
                    let lines = lineBuffer.split('\n');
                    while (lines.length > 1) {
                        const line = lines.shift().trim();
                        if (line) processData(line);
                    }
                    lineBuffer = lines[0];
                }
            } catch (error) {} finally {
                reader.releaseLock();
                await readableStreamClosed;
                if (port && port.writable) await port.close();
                updateConnectionStatus(false);
            }
        }

        function processData(data) {
            // *** UPDATED: Now expects 6 data points (w,x,y,z,temp,accel) ***
            const parts = data.split(',');
            if (parts.length === 6) {
                // MPU6050 quaternion order is w, x, y, z
                // three.js quaternion constructor is (x, y, z, w)
                const w = parseFloat(parts[0]);
                const x = parseFloat(parts[1]);
                const y = parseFloat(parts[2]);
                const z = parseFloat(parts[3]);
                const tempF = parseFloat(parts[4]);
                const accelG = parseFloat(parts[5]);

                if (!isNaN(w)) {
                    currentQuaternion.set(x, y, z, w);
                }
                if (!isNaN(accelG)) currentAccelG = accelG;
                if (!isNaN(tempF)) {
                    document.getElementById('temp-val').textContent = tempF.toFixed(2);
                }
                updateDisplays();
            }
        }
        
        function zeroPosition() {
            // Get the inverse of the current orientation. This will be our "zero"
            zeroOffsetQuaternion = currentQuaternion.clone().conjugate();
            zeroOffsetAccel = currentAccelG;
            updateDisplays();
        }

        function updateDisplays() {
            // Apply the zeroing offset to the current quaternion to get the relative rotation
            const relativeQuaternion = zeroOffsetQuaternion.clone().multiply(currentQuaternion);

            // *** FIX: Apply the final quaternion directly to the model ***
            modelGroup.setRotationFromQuaternion(relativeQuaternion);
            
            // For display purposes, convert the relative quaternion back to Euler angles
            const euler = new THREE.Euler().setFromQuaternion(relativeQuaternion, 'YXZ');
            const relativeYaw = THREE.MathUtils.radToDeg(euler.y);
            const relativePitch = THREE.MathUtils.radToDeg(euler.x);
            const relativeRoll = THREE.MathUtils.radToDeg(euler.z);

            const relativeAccel = currentAccelG - zeroOffsetAccel;

            document.getElementById('yaw-val').textContent = (-relativeYaw).toFixed(2);
            document.getElementById('pitch-val').textContent = relativePitch.toFixed(2);
            document.getElementById('roll-val').textContent = (-relativeRoll).toFixed(2);
            document.getElementById('accel-val').textContent = relativeAccel.toFixed(2);
        }

        function updateConnectionStatus(isConnected) {
            const statusDot = document.getElementById('status-dot');
            const statusText = document.getElementById('status-text');
            const zeroButton = document.getElementById('zero-button');
            const connectButton = document.getElementById('connect-button');

            if (isConnected) {
                statusDot.className = 'status-dot status-connected';
                statusText.textContent = 'Connected';
                connectButton.textContent = 'Disconnect';
                connectButton.onclick = disconnectSerial;
                zeroButton.disabled = false;
            } else {
                statusDot.className = 'status-dot status-disconnected';
                statusText.textContent = 'Disconnected';
                connectButton.textContent = 'Connect';
                connectButton.onclick = connectSerial;
                zeroButton.disabled = true;
                zeroOffsetQuaternion.set(0, 0, 0, 1); // Reset to identity
                zeroOffsetAccel = 0;
                updateDisplays();
            }
        }

        async function disconnectSerial() {
            if (reader) await reader.cancel();
        }
        
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        init();
    </script>
</body>
</html>
